﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" #>
<#@ assembly name="PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xaml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ assembly name="WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35" #>
<#@ import namespace="System.Windows" #>
<#@ import namespace="System.Windows.Controls" #>
<#@ output extension=".generated.txt" #>
namespace Gu.Wpf.NumericInput
{
    using System;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Input;
<#
    var events = new []
    {
        UIElement.GotKeyboardFocusEvent, 
		UIElement.MouseUpEvent,
		UIElement.PreviewMouseLeftButtonDownEvent,
		UIElement.MouseLeftButtonDownEvent,
		Control.MouseDoubleClickEvent,
    }; #>

    internal static class WeakRoutedEventManager
    {
        internal static void AddWeakHandler(
            this UIElement source,
            RoutedEvent routedEvent,
            EventHandler<RoutedEventArgs> handler,
            bool handledEventsToo = false)
        {
            switch (routedEvent.Name)
            {
<#  foreach (var routedEvent in events)
    { #>
                case nameof(<#= routedEvent.OwnerType.Name #>.<#= routedEvent.Name #>):
                    <#= routedEvent.Name #>EventManager.AddHandler(source, handler, handledEventsToo);
                    break;
<# } #>
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        internal static void RemoveWeakHandler(
            this UIElement source,
            RoutedEvent routedEvent,
            EventHandler<RoutedEventArgs> handler)
        {
            switch (routedEvent.Name)
            {
<#  foreach (var routedEvent in events)
    { #>
                case nameof(UIElement.<#= routedEvent.Name #>):
                    <#= routedEvent.Name #>EventManager.RemoveHandler(source, handler);
                    break;
<# } #>
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }
<#  foreach (var routedEvent in events)
    { #>

    internal class <#= routedEvent.Name #>EventManager : WeakEventManager
    {
        private readonly RoutedEventHandler handler;
        private bool handledEventsToo;

        private <#= routedEvent.Name #>EventManager()
        {
            this.handler = new RoutedEventHandler(this.On<#= routedEvent.Name #>);
        }

        // get the event manager for the current thread
        private static <#= routedEvent.Name #>EventManager CurrentManager
        {
            get
            {
                var managerType = typeof(<#= routedEvent.Name #>EventManager);
                var manager = (<#= routedEvent.Name #>EventManager)GetCurrentManager(managerType);

                // at first use, create and register a new manager
                if (manager == null)
                {
                    manager = new <#= routedEvent.Name #>EventManager();
                    SetCurrentManager(managerType, manager);
                }

                return manager;
            }
        }

        /// <summary>
        /// Add a listener to the given source's event.
        /// </summary>
        internal static void AddListener(UIElement source, IWeakEventListener listener, bool handledEventsToo)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            if (listener == null)
            {
                throw new ArgumentNullException(nameof(listener));
            }

            var manager = CurrentManager;
            manager.handledEventsToo = handledEventsToo;
            manager.ProtectedAddListener(source, listener);
        }

        /// <summary>
        /// Remove a listener to the given source's event.
        /// </summary>
        internal static void RemoveListener(UIElement source, IWeakEventListener listener)
        {
            if (source == null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            if (listener == null)
            {
                throw new ArgumentNullException(nameof(listener));
            }

            CurrentManager.ProtectedRemoveListener(source, listener);
        }

        /// <summary>
        /// Add a handler for the given source's event.
        /// </summary>
        internal static void AddHandler(UIElement source, EventHandler<RoutedEventArgs> handler, bool handledEventsToo)
        {
            if (handler == null)
            {
                throw new ArgumentNullException(nameof(handler));
            }

            var manager = CurrentManager;
            manager.handledEventsToo = handledEventsToo;
            manager.ProtectedAddHandler(source, handler);
        }

        /// <summary>
        /// Remove a handler for the given source's event.
        /// </summary>
        internal static void RemoveHandler(UIElement source, EventHandler<RoutedEventArgs> handler)
        {
            if (handler == null)
            {
                throw new ArgumentNullException(nameof(handler));
            }

            CurrentManager.ProtectedRemoveHandler(source, handler);
        }

        /// <summary>
        /// Return a new list to hold listeners to the event.
        /// </summary>
        protected override ListenerList NewListenerList()
        {
            return new ListenerList<RoutedEventArgs>();
        }

        /// <summary>
        /// Listen to the given source for the event.
        /// </summary>
        protected override void StartListening(object source)
        {
            var uiElement = (UIElement)source;
            uiElement.AddHandler(UIElement.<#= routedEvent.Name #>Event, this.handler, this.handledEventsToo);
        }

        /// <summary>
        /// Stop listening to the given source for the event.
        /// </summary>
        protected override void StopListening(object source)
        {
            var uiElement = (UIElement)source;
            uiElement.RemoveHandler(UIElement.<#= routedEvent.Name #>Event, this.handler);
        }

        // event handler for <#= routedEvent.Name #> event
        private void On<#= routedEvent.Name #>(object sender, RoutedEventArgs args)
        {
            this.DeliverEvent(sender, args);
        }
    }
<#    } #>
}